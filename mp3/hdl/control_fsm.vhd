-- VHDL Entity ece411.Control.interface
--
-- Created:
--          by - jconroy2.stdt (eelnx39.ews.illinois.edu)
--          at - 20:57:45 10/18/10
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2005.3 (Build 75)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;

ENTITY Control IS
   PORT( 
      ADDR0out       : IN     std_logic;
      CheckN         : IN     std_logic;
      CheckP         : IN     std_logic;
      CheckZ         : IN     std_logic;
      IR11           : IN     std_logic;
      IR4            : IN     std_logic;
      IR5            : IN     std_logic;
      MRESP_H        : IN     std_logic;
      Opcode         : IN     LC3b_opcode;
      RESET_L        : IN     std_logic;
      START_H        : IN     std_logic;
      clk            : IN     std_logic;
      n              : IN     std_logic;
      p              : IN     std_logic;
      z              : IN     std_logic;
      ALUMuxSel      : OUT    std_logic;
      ALUop          : OUT    LC3b_aluop;
      DataMuxSel     : OUT    lc3b_4mux_sel;
      DataOutMuxSel  : OUT    lc3b_4mux_sel;
      ImmMuxSel      : OUT    lc3b_4mux_sel;
      LEAMuxSel      : OUT    std_logic;
      LoadIR         : OUT    std_logic;
      LoadMAR        : OUT    std_logic;
      LoadMDR        : OUT    std_logic;
      LoadNZP        : OUT    std_logic;
      LoadPC         : OUT    std_logic;
      MARMuxSel      : OUT    std_logic;
      MDRMuxSel      : OUT    std_logic;
      MDRPCMuxSel    : OUT    std_logic;
      MDRtoMARMuxSel : OUT    std_logic;
      MREAD_L        : OUT    std_logic;
      MWRITEH_L      : OUT    std_logic;
      MWRITEL_L      : OUT    std_logic;
      PCMuxSel       : OUT    std_logic;
      PCOffMuxSel    : OUT    std_logic;
      PCRegMuxSel    : OUT    std_logic;
      RFMuxSel       : OUT    std_logic;
      RegPCMuxSel    : OUT    std_logic;
      RegWrite       : OUT    std_logic;
      StoreSR        : OUT    std_logic;
      TRAPMuxSel     : OUT    std_logic;
      destMuxSel     : OUT    std_logic
   );

-- Declarations

END Control ;

--
-- VHDL Architecture ece411.Control.fsm
--
-- Created:
--          by - jconroy2.stdt (eelnx39.ews.illinois.edu)
--          at - 20:57:46 10/18/10
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2005.3 (Build 75)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;
 
ARCHITECTURE fsm OF Control IS

   TYPE STATE_TYPE IS (
      Reset,
      Decode,
      L_NOT,
      IF1,
      IF2,
      IF3,
      CalcADDR,
      ST1,
      LD1,
      ST2,
      LD2,
      ADD_Register,
      ADD_start,
      ADD_immediate,
      AND_Register,
      AND_immediate,
      AND_start,
      JMP,
      BR2,
      BR1,
      LEA,
      SavePCJSR,
      JSR,
      JSRR,
      CalcADDRB,
      STB,
      LDB1,
      STBH1,
      STBL1,
      LDBL,
      LDBH,
      STBH2,
      STBL2,
      CalcADDRI1,
      STI1,
      CalcADDRI2,
      STI2,
      LDI2,
      CalcADDRI3,
      LDI1,
      SHFstart,
      LSHF,
      RSHFL,
      RSHFA,
      SavePCTrap,
      CalcADDRTR1,
      CalcADDRTR2,
      TRAPJMP
   );
 
   -- State vector declaration
   ATTRIBUTE state_vector : string;
   ATTRIBUTE state_vector OF fsm : ARCHITECTURE IS "current_state";

   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      clk,
      RESET_L
   )
   -----------------------------------------------------------------
   BEGIN
      IF (RESET_L = '0') THEN
         current_state <= Reset;
      ELSIF (clk'EVENT AND clk = '1') THEN
         current_state <= next_state;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      ADDR0out,
      CheckN,
      CheckP,
      CheckZ,
      IR11,
      IR4,
      IR5,
      MRESP_H,
      Opcode,
      START_H,
      current_state,
      n,
      p,
      z
   )
   -----------------------------------------------------------------
   BEGIN
      CASE current_state IS
         WHEN Reset => 
            IF (START_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= Reset;
            END IF;
         WHEN Decode => 
            IF ((Opcode = op_ldr) OR
                (Opcode = op_str)) THEN 
               next_state <= CalcADDR;
            ELSIF (Opcode = op_not) THEN 
               next_state <= L_NOT;
            ELSIF (Opcode = op_and) THEN 
               next_state <= AND_start;
            ELSIF (Opcode = op_add) THEN 
               next_state <= ADD_start;
            ELSIF (Opcode = op_jmp) THEN 
               next_state <= JMP;
            ELSIF (Opcode = op_br) THEN 
               next_state <= BR1;
            ELSIF (Opcode = op_lea) THEN 
               next_state <= LEA;
            ELSIF (Opcode = op_jsr) THEN 
               next_state <= SavePCJSR;
            ELSIF ((Opcode = op_ldb) OR
                   (Opcode = op_stb)) THEN 
               next_state <= CalcADDRB;
            ELSIF ((Opcode = op_ldi) OR
                   (Opcode = op_sti)) THEN 
               next_state <= CalcADDRI1;
            ELSIF (Opcode = op_shf) THEN 
               next_state <= SHFstart;
            ELSIF (Opcode = op_trap) THEN 
               next_state <= SavePCTrap;
            ELSE
               next_state <= IF1;
            END IF;
         WHEN L_NOT => 
            next_state <= IF1;
         WHEN IF1 => 
            next_state <= IF2;
         WHEN IF2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF3;
            ELSE
               next_state <= IF2;
            END IF;
         WHEN IF3 => 
            next_state <= Decode;
         WHEN CalcADDR => 
            IF (Opcode = op_str) THEN 
               next_state <= ST1;
            ELSIF (Opcode = op_ldr) THEN 
               next_state <= LD1;
            ELSE
               next_state <= CalcADDR;
            END IF;
         WHEN ST1 => 
            next_state <= ST2;
         WHEN LD1 => 
            IF (MRESP_H = '1') THEN 
               next_state <= LD2;
            ELSE
               next_state <= LD1;
            END IF;
         WHEN ST2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= ST2;
            END IF;
         WHEN LD2 => 
            next_state <= IF1;
         WHEN ADD_Register => 
            next_state <= IF1;
         WHEN ADD_start => 
            IF (IR5 = '0') THEN 
               next_state <= ADD_Register;
            ELSIF (IR5 = '1') THEN 
               next_state <= ADD_immediate;
            ELSE
               next_state <= ADD_start;
            END IF;
         WHEN ADD_immediate => 
            next_state <= IF1;
         WHEN AND_Register => 
            next_state <= IF1;
         WHEN AND_immediate => 
            next_state <= IF1;
         WHEN AND_start => 
            IF (IR5 = '0') THEN 
               next_state <= AND_Register;
            ELSIF (IR5 = '1') THEN 
               next_state <= AND_immediate;
            ELSE
               next_state <= AND_start;
            END IF;
         WHEN JMP => 
            next_state <= IF1;
         WHEN BR2 => 
            next_state <= IF1;
         WHEN BR1 => 
            IF (( ( n AND CheckN ) OR
                ( p AND CheckP ) OR
                ( z AND CheckZ ) ) = '1') THEN 
               next_state <= BR2;
            ELSE
               next_state <= IF1;
            END IF;
         WHEN LEA => 
            next_state <= IF1;
         WHEN SavePCJSR => 
            IF (IR11 = '1') THEN 
               next_state <= JSR;
            ELSIF (IR11 = '0') THEN 
               next_state <= JSRR;
            ELSE
               next_state <= SavePCJSR;
            END IF;
         WHEN JSR => 
            next_state <= IF1;
         WHEN JSRR => 
            next_state <= IF1;
         WHEN CalcADDRB => 
            IF (Opcode = op_stb) THEN 
               next_state <= STB;
            ELSIF (Opcode = op_ldb) THEN 
               next_state <= LDB1;
            ELSE
               next_state <= CalcADDRB;
            END IF;
         WHEN STB => 
            IF (ADDR0out = '1') THEN 
               next_state <= STBH1;
            ELSIF (ADDR0out = '0') THEN 
               next_state <= STBL1;
            ELSE
               next_state <= STB;
            END IF;
         WHEN LDB1 => 
            IF ((MRESP_H = '1') AND
                (ADDR0out = '1')) THEN 
               next_state <= LDBL;
            ELSIF ((MRESP_H = '1') AND
                   (ADDR0out ='0')) THEN 
               next_state <= LDBH;
            ELSE
               next_state <= LDB1;
            END IF;
         WHEN STBH1 => 
            next_state <= STBH2;
         WHEN STBL1 => 
            next_state <= STBL2;
         WHEN LDBL => 
            next_state <= IF1;
         WHEN LDBH => 
            next_state <= IF1;
         WHEN STBH2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= STBH2;
            END IF;
         WHEN STBL2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= STBL2;
            END IF;
         WHEN CalcADDRI1 => 
            next_state <= CalcADDRI2;
         WHEN STI1 => 
            next_state <= STI2;
         WHEN CalcADDRI2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= CalcADDRI3;
            ELSE
               next_state <= CalcADDRI2;
            END IF;
         WHEN STI2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= STI2;
            END IF;
         WHEN LDI2 => 
            next_state <= IF1;
         WHEN CalcADDRI3 => 
            IF (Opcode = op_ldi) THEN 
               next_state <= LDI1;
            ELSIF (Opcode = op_sti) THEN 
               next_state <= STI1;
            ELSE
               next_state <= CalcADDRI3;
            END IF;
         WHEN LDI1 => 
            IF (MRESP_H = '1') THEN 
               next_state <= LDI2;
            ELSE
               next_state <= LDI1;
            END IF;
         WHEN SHFstart => 
            IF ((IR5 = '0') AND
                (IR4 = '1')) THEN 
               next_state <= RSHFL;
            ELSIF ((IR5 = '1') AND
                   (IR4 = '1')) THEN 
               next_state <= RSHFA;
            ELSIF (IR4 = '0') THEN 
               next_state <= LSHF;
            ELSE
               next_state <= SHFstart;
            END IF;
         WHEN LSHF => 
            next_state <= IF1;
         WHEN RSHFL => 
            next_state <= IF1;
         WHEN RSHFA => 
            next_state <= IF1;
         WHEN SavePCTrap => 
            next_state <= CalcADDRTR1;
         WHEN CalcADDRTR1 => 
            next_state <= CalcADDRTR2;
         WHEN CalcADDRTR2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= TRAPJMP;
            ELSE
               next_state <= CalcADDRTR2;
            END IF;
         WHEN TRAPJMP => 
            next_state <= IF1;
         WHEN OTHERS =>
            next_state <= Reset;
      END CASE;
   END PROCESS nextstate_proc;
 
   -----------------------------------------------------------------
   output_proc : PROCESS ( 
      current_state
   )
   -----------------------------------------------------------------
   BEGIN
      -- Default Assignment
      ALUMuxSel <= '0';
      ALUop <= "000";
      DataMuxSel <= "00";
      DataOutMuxSel <= "00";
      ImmMuxSel <= "00";
      LEAMuxSel <= '0';
      LoadIR <= '0';
      LoadMAR <= '0';
      LoadMDR <= '0';
      LoadNZP <= '0';
      LoadPC <= '0';
      MARMuxSel <= '0';
      MDRMuxSel <= '0';
      MDRPCMuxSel <= '0';
      MDRtoMARMuxSel <= '0';
      MREAD_L <= '1';
      MWRITEH_L <= '1';
      MWRITEL_L <= '1';
      PCMuxSel <= '0';
      PCOffMuxSel <= '0';
      PCRegMuxSel <= '0';
      RFMuxSel <= '0';
      RegPCMuxSel <= '0';
      RegWrite <= '0';
      StoreSR <= '1';
      TRAPMuxSel <= '0';
      destMuxSel <= '0';

      -- Combined Actions
      CASE current_state IS
         WHEN L_NOT => 
            ALUop <= alu_not;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
            LEAMuxSel <= '0';
            ALUMuxSel <= '0';
         WHEN IF1 => 
            LoadMAR <= '1';
            LoadPC <= '1';
         WHEN IF2 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6 ns;
         WHEN IF3 => 
            LoadIR <= '1';
         WHEN CalcADDR => 
            ALUMuxSel <= '1';
            ALUop <= alu_add;
            MARMuxSel <= '1';
            LoadMAR <= '1';
            ImmMuxSel <= "00";
         WHEN ST1 => 
            StoreSR <= '0';
            ALUop <= alu_pass;
            LoadMDR <= '1';
            MDRMuxSel <= '1';
            DataOutMuxSel <= "00";
         WHEN LD1 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6 ns;
         WHEN ST2 => 
            MWRITEL_L <= '0' after 6 ns;
            MWRITEH_L <= '0' after 6 ns;
         WHEN LD2 => 
            DataMuxSel <= "00";
            PCRegMuxSel <= '0';
            RegWrite <= '1';
            LoadNZP <= '1';
         WHEN ADD_Register => 
            ALUop <= alu_add;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
            ALUMuxSel <= '0';
            LEAMuxSel <= '0';
         WHEN ADD_immediate => 
            ALUop <= alu_add;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
            ImmMuxSel <= "10";
            ALUMuxSel <= '1';
            LEAMuxSel <= '0';
         WHEN AND_Register => 
            ALUop <= alu_and;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
            ALUMuxSel <= '0';
            LEAMuxSel <= '0';
         WHEN AND_immediate => 
            ALUop <= alu_and;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
            ImmMuxSel <= "10";
            ALUMuxSel <= '1';
            LEAMuxSel <= '0';
         WHEN JMP => 
            ALUop <= alu_pass;
            PCMuxSel <= '1';
            RegPCMuxSel <= '1';
            LoadPC <= '1';
         WHEN BR2 => 
            PCOffMuxSel <= '0';
            RegPCMuxSel <= '0';
            PCMuxSel <= '1';
            LoadPC <= '1';
         WHEN LEA => 
            LEAMuxSel <= '1';
            RegWrite <=  '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
         WHEN SavePCJSR => 
            destMuxSel <= '1';
            RegWrite <= '1';
            PCRegMuxSel <= '1';
         WHEN JSR => 
            PCOffMuxSel <= '1';
            RegPCMuxSel <= '0';
            PCMuxSel <= '1';
            LoadPC <= '1';
         WHEN JSRR => 
            ALUop <= ALU_PASS;
            RegPCMuxSel <= '1';
            PCMuxSel <= '1';
            LoadPC <= '1';
         WHEN CalcADDRB => 
            ALUMuxSel <= '1';
            ALUop <= alu_add;
            MARMuxSel <= '1';
            LoadMAR <= '1';
            ImmMuxSel <= "01";
         WHEN LDB1 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6 ns;
         WHEN STBH1 => 
            StoreSR <= '0';
            ALUop <= alu_pass;
            LoadMDR <= '1';
            MDRMuxSel <= '1';
            DataOutMuxSel <= "11";
         WHEN STBL1 => 
            StoreSR <= '0';
            ALUop <= alu_pass;
            LoadMDR <= '1';
            MDRMuxSel <= '1';
            DataOutMuxSel <= "10";
         WHEN LDBL => 
            DataMuxSel <= "11";
            PCRegMuxSel <= '0';
            RFMuxSel <= '0';
            RegWrite <= '1';
            LoadNZP <= '1';
         WHEN LDBH => 
            DataMuxSel <= "10";
            PCRegMuxSel <= '0';
            RFMuxSel <= '0';
            RegWrite <= '1';
            LoadNZP <= '1';
         WHEN STBH2 => 
            MWRITEH_L
             <= '0' after 6 ns;
         WHEN STBL2 => 
            MWRITEL_L
             <= '0' after 6ns;
         WHEN CalcADDRI1 => 
            ALUMuxSel <= '1';
            ALUop <= alu_add;
            MDRtoMARMuxSel <= '0';
            MARMuxSel <= '1';
            LoadMAR <= '1';
            ImmMuxSel <= "00";
         WHEN STI1 => 
            StoreSR <= '0';
            ALUop <= alu_pass;
            LoadMDR <= '1';
            MDRMuxSel <= '1';
            DataOutMuxSel <= "00";
         WHEN CalcADDRI2 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6 ns;
         WHEN STI2 => 
            MWRITEL_L <= '0' after 6 ns;
            MWRITEH_L <= '0' after 6 ns;
         WHEN LDI2 => 
            DataMuxSel <= "00";
            PCRegMuxSel <= '0';
            RegWrite <= '1';
            LoadNZP <= '1';
         WHEN CalcADDRI3 => 
            MDRtoMARMuxSel <= '1';
            MARMuxSel <= '1';
            LoadMAR <= '1';
         WHEN LDI1 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6 ns;
         WHEN LSHF => 
            ALUop <= alu_sll;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
            ImmMuxSel <= "11";
            ALUMuxSel <= '1';
            LEAMuxSel <= '0';
         WHEN RSHFL => 
            ALUop <= alu_srl;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
            ImmMuxSel <= "11";
            ALUMuxSel <= '1';
            LEAMuxSel <= '0';
         WHEN RSHFA => 
            ALUop <= alu_sra;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= '1';
            ImmMuxSel <= "11";
            ALUMuxSel  <= '1';
            LEAMuxSel <= '0';
         WHEN SavePCTrap => 
            destMuxSel <= '1';
            RegWrite <= '1';
            PCRegMuxSel <= '1';
         WHEN CalcADDRTR1 => 
            ALUMuxSel <= '1';
            ALUop <= alu_add;
            MDRtoMARMuxSel <= '0';
            MARMuxSel <= '0';
            LoadMAR <= '1';
            TRAPMuxSel <= '1';
         WHEN CalcADDRTR2 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6 ns;
         WHEN TRAPJMP => 
            MDRPCMuxSel <= '1';
            PCMuxSel <= '0';
            LoadPC <= '1';
         WHEN OTHERS =>
            NULL;
      END CASE;
   END PROCESS output_proc;
 
END fsm;
